$date
	Fri Aug  8 16:30:34 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module cpu_testbench $end
$var wire 1 ! zero_flag_out $end
$var wire 16 " pc_out [15:0] $end
$var wire 1 # overflow_flag_out $end
$var wire 16 $ instruction_out [15:0] $end
$var wire 1 % carry_flag_out $end
$var wire 16 & alu_result_out [15:0] $end
$var reg 1 ' clk $end
$var reg 1 ( reset $end
$scope module cpu_dut $end
$var wire 16 ) alu_operand_a [15:0] $end
$var wire 16 * alu_result_out [15:0] $end
$var wire 1 % carry_flag_out $end
$var wire 1 ' clk $end
$var wire 16 + instruction_out [15:0] $end
$var wire 1 # overflow_flag_out $end
$var wire 16 , pc_out [15:0] $end
$var wire 1 ( reset $end
$var wire 1 ! zero_flag_out $end
$var wire 1 - zero_flag $end
$var wire 3 . rs2 [2:0] $end
$var wire 3 / rs1 [2:0] $end
$var wire 1 0 reg_write_enable $end
$var wire 16 1 reg_write_data [15:0] $end
$var wire 3 2 reg_write_addr [2:0] $end
$var wire 16 3 reg_data2 [15:0] $end
$var wire 16 4 reg_data1 [15:0] $end
$var wire 16 5 pc [15:0] $end
$var wire 1 6 overflow_flag $end
$var wire 1 7 mem_write $end
$var wire 1 8 mem_to_reg $end
$var wire 1 9 mem_ready $end
$var wire 16 : mem_read_data [15:0] $end
$var wire 1 ; mem_read $end
$var wire 16 < mem_address [15:0] $end
$var wire 12 = jump_addr [11:0] $end
$var wire 1 > jump $end
$var wire 1 ? instruction_ready $end
$var wire 16 @ instruction [15:0] $end
$var wire 8 A immediate [7:0] $end
$var wire 1 B carry_flag $end
$var wire 1 C branch $end
$var wire 1 D alu_src $end
$var wire 16 E alu_result [15:0] $end
$var wire 16 F alu_operand_b [15:0] $end
$var wire 4 G alu_control [3:0] $end
$scope module alu_unit $end
$var wire 16 H operand_a [15:0] $end
$var wire 16 I operand_b [15:0] $end
$var wire 1 - zero_flag $end
$var wire 17 J sub_result [16:0] $end
$var wire 4 K alu_control [3:0] $end
$var wire 17 L add_result [16:0] $end
$var parameter 4 M ALU_ADD $end
$var parameter 4 N ALU_AND $end
$var parameter 4 O ALU_OR $end
$var parameter 4 P ALU_SLL $end
$var parameter 4 Q ALU_SLT $end
$var parameter 4 R ALU_SRL $end
$var parameter 4 S ALU_SUB $end
$var parameter 4 T ALU_XOR $end
$var reg 1 B carry_flag $end
$var reg 1 6 overflow_flag $end
$var reg 16 U result [15:0] $end
$upscope $end
$scope module ctrl_unit $end
$var wire 3 V rs2 [2:0] $end
$var wire 3 W rs1 [2:0] $end
$var wire 3 X rd [2:0] $end
$var wire 4 Y opcode [3:0] $end
$var wire 16 Z instruction [15:0] $end
$var wire 8 [ imm8 [7:0] $end
$var wire 6 \ imm6 [5:0] $end
$var wire 12 ] addr12 [11:0] $end
$var parameter 4 ^ OP_ADD $end
$var parameter 4 _ OP_ADDI $end
$var parameter 4 ` OP_AND $end
$var parameter 4 a OP_ANDI $end
$var parameter 4 b OP_BEQ $end
$var parameter 4 c OP_JMP $end
$var parameter 4 d OP_LW $end
$var parameter 4 e OP_NOP $end
$var parameter 4 f OP_OR $end
$var parameter 4 g OP_ORI $end
$var parameter 4 h OP_SLL $end
$var parameter 4 i OP_SLT $end
$var parameter 4 j OP_SRL $end
$var parameter 4 k OP_SUB $end
$var parameter 4 l OP_SW $end
$var parameter 4 m OP_XOR $end
$var reg 4 n alu_control [3:0] $end
$var reg 1 D alu_src $end
$var reg 1 C branch $end
$var reg 8 o immediate [7:0] $end
$var reg 1 > jump $end
$var reg 12 p jump_addr [11:0] $end
$var reg 1 ; mem_read $end
$var reg 1 8 mem_to_reg $end
$var reg 1 7 mem_write $end
$var reg 3 q reg_write_addr [2:0] $end
$var reg 1 0 reg_write_enable $end
$upscope $end
$scope module if_unit $end
$var wire 1 C branch $end
$var wire 8 r branch_offset [7:0] $end
$var wire 1 ' clk $end
$var wire 1 > jump $end
$var wire 12 s jump_address [11:0] $end
$var wire 1 ( reset $end
$var wire 1 - zero_flag $end
$var reg 16 t instruction [15:0] $end
$var reg 1 ? instruction_ready $end
$var reg 16 u pc [15:0] $end
$var reg 16 v pc_next [15:0] $end
$var integer 32 w i [31:0] $end
$upscope $end
$scope module mem_if $end
$var wire 16 x address [15:0] $end
$var wire 1 ' clk $end
$var wire 1 ; mem_read $end
$var wire 1 7 mem_write $end
$var wire 1 ( reset $end
$var wire 16 y write_data [15:0] $end
$var reg 1 9 mem_ready $end
$var reg 16 z read_data [15:0] $end
$var integer 32 { i [31:0] $end
$upscope $end
$scope module reg_file $end
$var wire 1 ' clk $end
$var wire 3 | read_addr1 [2:0] $end
$var wire 3 } read_addr2 [2:0] $end
$var wire 1 ( reset $end
$var wire 3 ~ write_addr [2:0] $end
$var wire 16 !" write_data [15:0] $end
$var wire 1 0 write_enable $end
$var wire 16 "" read_data2 [15:0] $end
$var wire 16 #" read_data1 [15:0] $end
$var integer 32 $" i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100 m
b1100 l
b1 k
b110 j
b111 i
b101 h
b1010 g
b11 f
b1111 e
b1011 d
b1110 c
b1101 b
b1001 a
b10 `
b1000 _
b0 ^
b100 T
b1 S
b110 R
b111 Q
b101 P
b11 O
b10 N
b0 M
$end
#0
$dumpvars
b1000 $"
b0 #"
b0 ""
b0 !"
b0 ~
b0 }
b0 |
b100000000000 {
b0 z
b0 y
b1000000000000 x
b100000000000 w
b1 v
b0 u
b0 t
b0 s
b0 r
b0 q
b0 p
b0 o
b0 n
b0 ]
b0 \
b0 [
b0 Z
b0 Y
b0 X
b0 W
b0 V
b0 U
b0 L
b0 K
b0 J
b0 I
b0 H
b0 G
b0 F
b0 E
0D
0C
0B
b0 A
b0 @
0?
0>
b0 =
b1000000000000 <
0;
b0 :
19
08
07
06
b0 5
b0 4
b0 3
b0 2
b0 1
10
b0 /
b0 .
1-
b0 ,
b0 +
b0 *
b0 )
1(
0'
b0 &
0%
b0 $
0#
b0 "
1!
$end
#5000
1'
#10000
0'
#15000
1'
#20000
0'
0(
#25000
b10000 1
b10000 !"
0!
0-
b1000000010000 <
b1000000010000 x
b10000 &
b10000 *
b10000 E
b10000 U
b10000 L
b11111111111110000 J
b10000 F
b10000 I
b10000 A
b10000 o
b10000 r
1D
b1 2
b1 q
b1 ~
10
b1000010000 ]
b10000 \
b10000 [
b10 X
b1 W
b1000 Y
b1 /
b1 |
b10 v
1?
b1000001000010000 $
b1000001000010000 +
b1000001000010000 @
b1000001000010000 Z
b1000001000010000 t
b1 "
b1 ,
b1 5
b1 u
19
1'
#30000
0'
#35000
b100000 1
b100000 !"
b1000000100000 <
b1000000100000 x
b100000 &
b100000 *
b100000 E
b100000 U
b100000 L
b11111111111100000 J
b100000 F
b100000 I
b100000 A
b100000 o
b100000 r
b10 2
b10 q
b10 ~
1D
10
b10000100000 ]
b100000 \
b100000 [
b100 X
b10 W
b10 /
b10 |
b11 v
19
b1000010000100000 $
b1000010000100000 +
b1000010000100000 @
b1000010000100000 Z
b1000010000100000 t
b10 "
b10 ,
b10 5
b10 u
1'
#40000
0'
#45000
b10000 F
b10000 I
b100000 1
b100000 !"
b0 A
b0 o
b0 r
b1 2
b1 q
b1 ~
0D
10
b10000 3
b10000 y
b10000 ""
b1000000100000 <
b1000000100000 x
b100000 &
b100000 *
b100000 E
b100000 U
b1001001001 ]
b1001 \
b1001001 [
b1 X
b1 V
b1 W
b0 Y
b1 .
b1 }
b1 /
b1 |
b100 v
b100000 L
b0 J
b10000 )
b10000 H
b10000 4
b10000 #"
b1001001001 $
b1001001001 +
b1001001001 @
b1001001001 Z
b1001001001 t
b11 "
b11 ,
b11 5
b11 u
19
1'
#50000
0'
#55000
b0 1
b0 !"
1!
1-
b1000000000000 <
b1000000000000 x
b0 &
b0 *
b0 E
b0 U
b0 F
b0 I
1D
17
b0 2
b0 q
b0 ~
00
b0 L
b0 J
b0 )
b0 H
b0 4
b0 #"
b0 3
b0 y
b0 ""
b11000000 ]
b0 \
b11000000 [
b0 X
b11 V
b0 W
b1100 Y
b11 .
b11 }
b0 /
b0 |
b101 v
19
b1100000011000000 $
b1100000011000000 +
b1100000011000000 @
b1100000011000000 Z
b1100000011000000 t
b100 "
b100 ,
b100 5
b100 u
1'
#60000
0'
#65000
0D
07
b111111111111 ]
b111111 \
b11111111 [
b111 X
b111 V
b111 W
b1111 Y
b111 .
b111 }
b111 /
b111 |
b110 v
b1111111111111111 $
b1111111111111111 +
b1111111111111111 @
b1111111111111111 Z
b1111111111111111 t
b101 "
b101 ,
b101 5
b101 u
19
1'
#70000
0'
#75000
b111 v
19
b110 "
b110 ,
b110 5
b110 u
1'
#80000
0'
#85000
b1000 v
b111 "
b111 ,
b111 5
b111 u
19
1'
#90000
0'
#95000
b1001 v
19
b1000 "
b1000 ,
b1000 5
b1000 u
1'
#100000
0'
#105000
b1010 v
b1001 "
b1001 ,
b1001 5
b1001 u
19
1'
#110000
0'
#115000
b1011 v
19
b1010 "
b1010 ,
b1010 5
b1010 u
1'
#120000
0'
#125000
b1100 v
b1011 "
b1011 ,
b1011 5
b1011 u
19
1'
#130000
0'
#135000
b1101 v
19
b1100 "
b1100 ,
b1100 5
b1100 u
1'
#140000
0'
#145000
b1110 v
b1101 "
b1101 ,
b1101 5
b1101 u
19
1'
#150000
0'
#155000
b1111 v
19
b1110 "
b1110 ,
b1110 5
b1110 u
1'
#160000
0'
#165000
b10000 v
b1111 "
b1111 ,
b1111 5
b1111 u
19
1'
#170000
0'
#175000
b10001 v
19
b10000 "
b10000 ,
b10000 5
b10000 u
1'
#180000
0'
#185000
b10010 v
b10001 "
b10001 ,
b10001 5
b10001 u
19
1'
#190000
0'
#195000
b10011 v
19
b10010 "
b10010 ,
b10010 5
b10010 u
1'
#200000
0'
#205000
b10100 v
b10011 "
b10011 ,
b10011 5
b10011 u
19
1'
#210000
0'
#215000
b10101 v
19
b10100 "
b10100 ,
b10100 5
b10100 u
1'
#220000
0'
#225000
10
b0 ]
b0 \
b0 [
b0 X
b0 V
b0 W
b0 Y
b0 .
b0 }
b0 /
b0 |
b1 v
0?
b0 $
b0 +
b0 @
b0 Z
b0 t
b0 "
b0 ,
b0 5
b0 u
b100000000000 {
b1000 $"
b100000000000 w
1'
1(
#230000
0'
#235000
b10000 1
b10000 !"
0!
0-
b1000000010000 <
b1000000010000 x
b10000 &
b10000 *
b10000 E
b10000 U
b10000 L
b11111111111110000 J
b10000 F
b10000 I
b10000 A
b10000 o
b10000 r
1D
b1 2
b1 q
b1 ~
10
b1000010000 ]
b10000 \
b10000 [
b10 X
b1 W
b1000 Y
b1 /
b1 |
b10 v
19
1?
b1000001000010000 $
b1000001000010000 +
b1000001000010000 @
b1000001000010000 Z
b1000001000010000 t
b1 "
b1 ,
b1 5
b1 u
1'
0(
#240000
0'
#245000
b100000 F
b100000 I
b100000 1
b100000 !"
b100000 A
b100000 o
b100000 r
b10 2
b10 q
b10 ~
1D
10
b1000000100000 <
b1000000100000 x
b100000 &
b100000 *
b100000 E
b100000 U
b10000100000 ]
b100000 \
b100000 [
b100 X
b10 W
b10 /
b10 |
b11 v
b100000 L
b11111111111100000 J
b0 )
b0 H
b0 4
b0 #"
b1000010000100000 $
b1000010000100000 +
b1000010000100000 @
b1000010000100000 Z
b1000010000100000 t
b10 "
b10 ,
b10 5
b10 u
19
1'
#250000
0'
#255000
b100000 1
b100000 !"
b10000 F
b10000 I
b1000000100000 <
b1000000100000 x
b100000 &
b100000 *
b100000 E
b100000 U
b0 A
b0 o
b0 r
b1 2
b1 q
b1 ~
0D
10
b10000 3
b10000 y
b10000 ""
b100000 L
b0 J
b10000 )
b10000 H
b10000 4
b10000 #"
b1001001001 ]
b1001 \
b1001001 [
b1 X
b1 V
b1 W
b0 Y
b1 .
b1 }
b1 /
b1 |
b100 v
19
b1001001001 $
b1001001001 +
b1001001001 @
b1001001001 Z
b1001001001 t
b11 "
b11 ,
b11 5
b11 u
1'
#260000
0'
#265000
1!
1-
b0 1
b0 !"
1D
17
b0 2
b0 q
b0 ~
00
b1000000000000 <
b1000000000000 x
b0 &
b0 *
b0 E
b0 U
b0 F
b0 I
b11000000 ]
b0 \
b11000000 [
b0 X
b11 V
b0 W
b1100 Y
b11 .
b11 }
b0 /
b0 |
b101 v
b0 L
b0 J
b0 )
b0 H
b0 4
b0 #"
b0 3
b0 y
b0 ""
b1100000011000000 $
b1100000011000000 +
b1100000011000000 @
b1100000011000000 Z
b1100000011000000 t
b100 "
b100 ,
b100 5
b100 u
19
1'
#270000
0'
#275000
0D
07
b111111111111 ]
b111111 \
b11111111 [
b111 X
b111 V
b111 W
b1111 Y
b111 .
b111 }
b111 /
b111 |
b110 v
19
b1111111111111111 $
b1111111111111111 +
b1111111111111111 @
b1111111111111111 Z
b1111111111111111 t
b101 "
b101 ,
b101 5
b101 u
1'
#280000
0'
#285000
b111 v
b110 "
b110 ,
b110 5
b110 u
19
1'
